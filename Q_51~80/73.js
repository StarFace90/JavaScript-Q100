// 전쟁이 끝난 후, A 나라에서는 폐허가 된 도시를 재건하려고 한다.
//그런데 이 땅은 전쟁의 중심지였으므로 전쟁 중 매립된 지뢰가 아직도 많이 남아 있다는 것이 판명되었다. 
// 정부는 가장 먼저 지뢰를 제거하기 위해 수색반을 꾸렸다.

// 수색반은 가장 효율적인 지뢰 제거가 하고 싶다. 수색반은 도시를 격자무늬로 나눠놓고 
//자신들이 수색할 수 있는 범위 내에 가장 많은 지뢰가 매립된 지역을 가장 먼저 작업하고 싶다.

// 가장 먼저 테스트 케이스의 수를 나타내는 1이상 100 이하의 자연수가 주어진다.
// 각 테스트 케이스의 첫 줄에는 수색할 도시의 크기 a와 수색반이 한 번에 수색 가능한 범위 b가 주어진다. 
// (a와 b 모두 정사각형의 가로 또는 세로를 나타낸다. 예를 들어 10이 주어지면 10x10칸의 크기를 나타낸다.)

// 그 후 a 줄에 걸쳐 도시 내 지뢰가 있는지의 여부가 나타난다. 
// 0은 지뢰가 없음 1은 지뢰가 있음을 뜻한다.

// 각 테스트 케이스에 대해 수색 가능한 범위 bxb 내에서 찾아낼 수 있는 가장 큰 지뢰의 개수를 구하라.

/**
 * 입력
1
5 3
1 0 0 1 0
0 1 0 0 1
0 0 0 1 0
0 0 0 0 0
0 0 1 0 0

출력
3
 */

// ? 풀이 

// 테스트 케이스의 수 : 1
// 테스트 케이스의 첫 줄 - a: 5(수색할 도시 크기)
// b : 3 (수색가능한 범위)

// a 줄에 걸쳐 도시 내 지뢰가 있는지 여부 

// 지뢰 있음 1,  지뢰 없음 0

// * output = 수색 가능한 범위 bxb 내에서 찾아낼 수 있는 가장 큰 지뢰의 개수

// 도시 범위 5 * 5
let cityWidth = 5;

// 수색 가능 범위 3 * 3
let searchArea = 3;

// 도시 내의 지뢰 여부
let mine = [
    [1, 0, 0, 1, 0],
    [0, 1, 0, 0, 1],
    [0, 0, 0, 1, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 1, 0, 0]];

// 지뢰 카운트 
let count = 0;

let arr = [];


// 도시 범위에서 수색가능한 범위를 제외한다. 
for (let i = 0; i <= cityWidth - searchArea; i++) {
    for (let j = 0; j <= cityWidth - searchArea; j++) {
        //console.log(i, j); // 3 * 3 
        //console.log(mine[i][j]); // 100 010 000 
        // count = count + mine[i][j];
        // 이거는 mine의 맨 왼쪽 범위 3 * 3 만 한 것이므로 이동을 시켜야한다. 그러려면 for..문..또??

        // 시작이 0이면 계속 왼쪽에서 머물것임.. -> 가로 이동은 i, 세로 이동은 j로 해봄
        // ? 위치럼 도시범위 - 수색가능 범위로 했는데 이동을 안하고 그대로 0 ~ 2까지만 움직임
        // ? 그런데 생각해 보면 반복 범위를 늘리지 않았다 ;; i ~ 2이기 때문.. 그렇기 때문에 i,j만큼 +를 해준다.
        for (let k = i; k <= cityWidth - searchArea + i; k++) {
            for (let h = j; h <= cityWidth - searchArea + j; h++) {
                // for문이 4개 라니 무섭다..
                // 항상 느끼는 거지만 for문이 많을 수록 그림이 안그려진다..
                // 이런거 잘하는 사람들 부럽..
                console.log("총 범위", k, h); // 0,0 ~ 4,4 까지 잘 나온다.
                // 아까 위에서 테스트한 count 를 여기서 사용한다.
                count = count + mine[k][h];
                // count가 18이 나온다. 범위를 다 걸치기 때문에 중복되는 수까지 겹친다.
                // 한 범위를 검색하면 count를 초기화 해주어야한다.
                // 이 수들을 담을 빈 배열도 만들자.
            }
        }
        arr.push(count);
        // 카운트 초기화 해야 범위를 이동해도 누적되지 않는다.
        count = 0;
        //[2, 3, 3, 1, 2, 2, 1, 2, 2] 잘 나온다. 이제 가장 큰 수를 내보낸다.
    }
}
// sort로 내림차순 정렬한다.
arr.sort((a, b) => b - a);
//console.log(arr);
console.log("가장 큰 지뢰 개수는", arr[0]);





// 해답 
// 해답도 for문을 사용해서 다행인건가??
// 마지막에 console.log(Math.max.apply(null, valueArray));
// apply를 이용해서 배열의 숫자중에 가장 큰 수를 출력하게 했다. (배울점)
// 좀 익숙해지면 for문이 아닌 다른 방법으로 풀어야겠다.

let 사각형 = 5;
let 탐색가능지역 = 3;
let 지뢰밭 = [
    [1, 0, 0, 1, 0],
    [0, 1, 0, 0, 1],
    [0, 0, 0, 1, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 1, 0, 0]
];

let iadd = 0;
let jadd = 0;
let value = 0;
let valueArray = [];
for (let iadd = 0; iadd <= 사각형 - 탐색가능지역; iadd++) {
    for (let jadd = 0; jadd <= 사각형 - 탐색가능지역; jadd++) {
        for (let i = iadd; i <= 탐색가능지역 - 1 + iadd; i++) {
            for (let j = jadd; j <= 탐색가능지역 - 1 + jadd; j++) {
                // console.log(i, j);
                value += 지뢰밭[i][j];
            }
        }
        valueArray.push(value);
        console.log("---------");
        value = 0;
    }
    console.log("!!!!!!!");
}

console.log(valueArray);
console.log(Math.max.apply(null, valueArray));