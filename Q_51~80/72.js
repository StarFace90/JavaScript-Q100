// 기린은 중국집에서 친구들과 만나기로 하고, 음식을 시켰습니다.
// 음식이 나오고 한참을 기다렸지만 만나기로 한 친구 2명이 오지 않았어요.

// 기린은 배가 너무 고파 혼자 음식을 먹기 시작합니다. 원형 테이블에는 N 개의 음식들이 있습니다.
// 한 개의 음식을 다 먹으면 그 음식의 시계방향으로 K 번째 음식을 먹습니다.
// 하지만 아직 오지 않은 친구들을 위해 2개의 접시를 남겨야 합니다.

// 마지막으로 남는 음식은 어떤 접시인가요?

//* 입력은 2개의 정수이며 공백이다. 첫 번째 숫자는 음식의 개수 N, 두 번째 숫자는 K이다.
//* 첫 번째 가져가는 음식이 K번째 음식이며, 나머지는 첫 번째 음식으로 부터 시계 방향으로 가져간다.

// 입력 6 3
// 출력 [3, 5]  (남은 음식 접시의 번호를 배열의 형태로 출력!)


// ? 풀이 

// 입,출력 예제를 바탕으로 문제에 접근한다.
//// 음식 6개 중에 k(3)번째 접시를 먼저 가져가고 첫 번째 음식으로 부터 시계 방향으로 4, 5, 6 순서대로 가져간다. 
// 친구를 위해 2개를 남긴다. 
// 근데 왜 3,5지??? (접시번호가 아닌가???)

// 이해가 안돼서 리스트를 만들어봤다. 
// arr = [1,2,3,4,5,6]  arr[3]은 -> 4이다. 첫 번째 가져가는 음식이 k번째 라면 음식4를 먼저 먹는 것이다.
// 나머지는 첫 번째 음식 arr[0] 부터 시계 방향으로 가져간다. [0]~[2].. 그래도 출력 조건이 이해가 안된다.
// *다시 문제를 자세히 읽는다. -> 한 개의 음식을 다 먹으면 그 음식의 시계방향으로 K 번째 음식을 먹습니다.
// 그렇게 되면 1은 무조건 먼저 먹고 그 다음 k번째인 4를 먹는다는 얘기다. 그리고 나서 K로 부터 시계 방향으로 
// 다음 K번째 음식을 먹으라는 얘기다.

/**
 * 즉 [1,2,3,4,5,6] 이고 k가 3이면, 
 * 맨 처음 음식(1)먹고,[2,3,4,5,6]
 * 3번째 음식인(4), [2,3,5,6]
 * 다음 3번째 음식인 (2) 가 될 것이다.[3,5,6]
 * 마지막으로 다음 3번째 음식인 (6) [3,5]
 */

// * 문제푸는데도 어려운데 문제 이해하는데도 이렇게 힘들면 어쩌라는지.. 내가 멍청한건가..



let input = '6 3';

let n = parseInt(input[0], 10); // 음식의 개수
let k = parseInt(input[2], 10); // 첫 번째로 가져는 음식들의 번호



let arr = [];

// 여기는 내가 위에 생각 한 배열 리스트 만든다. 
// [1,2,3,4,5,6]
for (let i = 0; i < n; i++) {
    arr.push(i + 1);
    // console.log(arr);
}

// // 만든 배열 가지고 어떻게 놀까??? -> 가지고 놀아지는 것은 나였다.

// 순서대로라면 arr[0], arr[3], arr[1], arr[5]가 빠진다.

// 즉 무식하게 한다면 이렇게 해야한다는 것 
// let c = arr.splice(0, 1);
// let d = arr.splice(2, 1);
// let e = arr.splice(0, 1);
// let f = arr.splice(2, 1);
// console.log(c);
// console.log(d);
// console.log(e);
// console.log(f);
// console.log(arr);

// 이걸 공식화 하려면 
// 길이 6개인 배열이 2개가 남을 때까지 점점 줄어드는 것..

// 여기서는 배열의 인덱스가 될 것이다
let num = 0;


// for문이나 for in이나 안맞는다..while로 간다.
// 6,5,4,3 
while (arr.length > 2) {
    // num이 남은 배열의 길이 보다 크면
    // 배열의 길이가 4일 때 남은 음식이 [2,3,5,6]인데 
    // num이 6라고 하면 ->  // num = 2이 되는 것
    // 그런데 이건 임의니까 예시대로 맞추면 [1,2,3,4,5,6] 일 때, 
    // 다음 3번째 접시를 먹으면 되니까 
    // arr[0]-> arr[3] -> arr[6] , 1(6) -> 4(5) -> 7(4) ? 인데 7은 없으니까 
    // 다음 순번인 2를 만드려면 7 - 4 = 3

    if (num > arr.length - 1) {
        // 7 - 4 = 3 이 된다. 이것을 2로 바꿔 주려면 위의 조건문에 길이 -1을 해줘야한다.
        num = num - arr.length;
    }
    arr.splice(num, 1);
    num = num + (k - 1);
}


console.log(arr);






// 해답

// 생각한 것과 거의 같은 풀이여서 다행인건지..
// 알고보면 간단한건데 내가 너무 못하는 거 같아서 걱정이다..
// 알고리즘은 거의 필수라는데.. 정말 걱정이다..


const user_input = prompt('입력해주세요').split(' ');
const n = parseInt(user_input[0], 10);
const k = parseInt(user_input[1], 10);

function sol(n, k) {
    let index = 0;
    // q에 n만큼의 숫자를 넣어준다.
    let q = [];
    for (let i = 0; i < n; i++) {
        q.push(i + 1);
    }

    while (q.length > 2) {
        if (index > q.length - 1) {
            // 순환하다 index가 q의 길이보다 클 경우에 q.length만큼 빼준다.
            // [1,2,3,4,5,6] -> 1다음 4가 빠지고 그 다음은 4+3 = 7(index : 6)이 빠져야 하는데
            // index(현재 빠져야 할 index)가 q.length보다 크므로 q.legnth, 즉 4를 빼준다.
            // 이걸 마지막 2개가 남을 때까지 반복한다.
            index -= q.length;
        }

        q.splice(index, 1);
        index += k;
        index -= 1;
    }

    return q;
}

console.log(sol(n, k));